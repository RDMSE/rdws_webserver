#pragma once
/**
 * Database Configuration Manager for C++ Microservices
 *
 * Reads configuration from:
 * 1. .env files (using dotenv-cpp third-party library)
 * 2. JSON file generated by deploy scripts
 * 3. Environment variables as fallback
 */

#include <cstdlib>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <stdexcept>
#include <string>
#include <vector>

#ifdef USE_JSON
    #include <nlohmann/json.hpp>
#endif

// dotenv-cpp third-party library
#include <dotenv.h>

namespace rdws {

class Config {
  private:
    std::string host;
    std::string port;
    std::string user;
    std::string password;
    std::string database;
    std::string environment;

    bool loadFromDotEnv(const std::string& env_name = "development") {
        try {
            // Try different .env file locations
            std::vector<std::string> env_files = {
                ".env." + env_name,                    // .env.development
                "../.env." + env_name,                 // from build directory
                "../../.env." + env_name,              // from nested build
                "/opt/rdws_webserver/.env." + env_name // production location
            };

            for (const auto& env_file : env_files) {
                if (std::filesystem::exists(env_file)) {
                    std::cout << "Loading .env from: " << env_file << std::endl;

                    // Load .env file using dotenv-cpp library
                    dotenv::init(env_file.c_str());

                    // Read values from environment (now set by dotenv)
                    loadFromEnvironment();
                    return true;
                }
            }

            std::cout << "No .env file found, trying environment variables..." << std::endl;
            return false;
        } catch (const std::exception& e) {
            std::cout << "Error loading .env file: " << e.what() << std::endl;
            return false;
        }
    }

    bool loadFromFile(const std::string& config_path = "/opt/rdws_webserver/config/database.json") {
        try {
#ifdef USE_JSON
            std::ifstream file(config_path);
            if (!file.is_open()) {
                return false;
            }

            nlohmann::json config;
            file >> config;

            host = config["host"].get<std::string>();
            port = std::to_string(config["port"].get<int>());
            user = config["user"].get<std::string>();
            password = config["password"].get<std::string>();
            database = config["database"].get<std::string>();
            environment = config["environment"].get<std::string>();

            std::cout << "Loaded config from JSON: " << config_path << std::endl;
            return true;
#else
            return false; // JSON support not compiled
#endif
        } catch (const std::exception& e) {
            return false;
        }
    }

    void loadFromEnvironment() {
        host = std::getenv("DB_HOST") ? std::getenv("DB_HOST") : "localhost";
        port = std::getenv("DB_PORT") ? std::getenv("DB_PORT") : "5432";
        user = std::getenv("DB_USER") ? std::getenv("DB_USER") : "postgres";
        password = std::getenv("DB_PASS") ? std::getenv("DB_PASS") : "";
        database = std::getenv("DB_NAME") ? std::getenv("DB_NAME") : "postgres";
        
        // Use RDWS_ENVIRONMENT from .bashrc, fallback to ENVIRONMENT, then development
        const char* rdws_env = std::getenv("RDWS_ENVIRONMENT");
        const char* env = std::getenv("ENVIRONMENT");
        environment = rdws_env ? rdws_env : (env ? env : "development");
    }

  public:
    Config(const std::string& env_name = "") {
        // Auto-detect environment from RDWS_ENVIRONMENT (set in .bashrc)
        std::string detected_env = env_name;
        if (detected_env.empty()) {
            const char* rdws_env = std::getenv("RDWS_ENVIRONMENT");
            const char* env = std::getenv("ENVIRONMENT");
            detected_env = rdws_env ? rdws_env : (env ? env : "development");
        }
        
        std::cout << "Detected environment: " << detected_env << std::endl;
        
        // Priority order:
        // 1. Environment variables (inherited from API Gateway process) - PREFERRED
        // 2. Try .env file (standalone mode)
        // 3. Try JSON config file (production deployment)

        bool loaded = false;

        // Check if we have environment variables set (from API Gateway or CI/CD)
        if (std::getenv("DB_HOST") && std::getenv("DB_NAME")) {
            std::cout << "Using environment variables from API Gateway/CI/CD" << std::endl;
            loadFromEnvironment();
            loaded = true;
        }
        // Check if we're in CI/CD (GitHub Actions, etc.)
        else if (std::getenv("GITHUB_ACTIONS") || std::getenv("CI")) {
            std::cout << "CI/CD environment detected, using environment variables" << std::endl;
            loadFromEnvironment();
            loaded = true;
        }
        // Standalone mode - try local .env file
        else {
            std::cout << "Standalone mode (" << detected_env << ") - trying local configuration..." << std::endl;

            // Try .env file first
            loaded = loadFromDotEnv(detected_env);

            // If no .env, try JSON config
            if (!loaded) {
                loaded = loadFromFile();
            }

            // Final fallback to environment
            if (!loaded) {
                std::cout << "Using environment variables as final fallback" << std::endl;
                loadFromEnvironment();
            }
        }

        // Validate required fields
        if (host.empty() || user.empty() || database.empty()) {
            throw std::runtime_error(
                "Database configuration incomplete. Required: host, user, database");
        }

        std::cout << getDebugInfo() << std::endl;
    }

    // Getters
    const std::string& getHost() const {
        return host;
    }
    const std::string& getPort() const {
        return port;
    }
    const std::string& getUser() const {
        return user;
    }
    const std::string& getPassword() const {
        return password;
    }
    const std::string& getDatabase() const {
        return database;
    }
    const std::string& getEnvironment() const {
        return environment;
    }

    // libpqxx connection string
    std::string getConnectionString() const {
        return "postgresql://" + user + ":" + password + "@" + host + ":" + port + "/" + database;
    }

    // Individual components for libpqxx connection
    std::string getLibpqxxString() const {
        return "host=" + host + " port=" + port + " dbname=" + database + " user=" + user +
               " password=" + password;
    }

    // Debug info (password hidden)
    std::string getDebugInfo() const {
        return "DB Config: " + user + "@" + host + ":" + port + "/" + database + " (" +
               environment + ")";
    }
};

} // namespace rdws
