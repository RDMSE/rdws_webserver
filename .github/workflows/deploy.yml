name: Deploy API Gateway + Microservices

on:
  push:
    branches: [ main ]
  workflow_dispatch:  # Allow manual trigger
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging

env:
  BUILD_DIR: ${{ github.workspace }}/build
  PRODUCTION_DIR: /opt/rdws_webserver
  NODE_VERSION: '20'

jobs:
  # Job 1: Build everything
  build:
    name: Build Microservices and API Gateway
    runs-on: [self-hosted, Linux, X64, webserver, fedora]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Clean and prepare
      run: |
        rm -rf build
        mkdir -p build

    - name: Verify environment and install dependencies
      run: |
        echo "Verifying deployment environment..."
        echo "Target directory: ${{ env.PRODUCTION_DIR }}"
        whoami
        pwd

        # Install Node.js if needed
        if ! command -v node &> /dev/null; then
          echo "Installing Node.js..."
          curl -fsSL https://rpm.nodesource.com/setup_lts.x | sudo bash -
          sudo dnf install -y nodejs
        fi

        # Install build tools if needed
        if ! command -v cmake &> /dev/null; then
          echo "Installing build tools..."
          sudo dnf install -y cmake gcc-c++ make
        fi

        # Install Google Test if needed
        if ! pkg-config --exists gtest; then
          echo "Installing Google Test..."
          sudo dnf install -y gtest-devel gmock-devel
        fi

        echo "Node.js version: $(node --version)"
        echo "npm version: $(npm --version)"
        echo "CMake version: $(cmake --version | head -1)"

    - name: Build C++ microservices
      run: |
        cd ${{ env.BUILD_DIR }}
        cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_STANDARD=17 -G "Unix Makefiles"
        make -j$(nproc)

        # Verify microservices were built
        echo "Verifying built microservices..."
        ls -la services/*/
        find . -name "*_service" -type f -executable
        ./services/users/users_service "GET" "/users" | head -2
        ./services/orders/orders_service "GET" "/orders" | head -2

    - name: Install API Gateway dependencies
      run: |
        npm ci

    - name: Run quick tests
      run: |
        # Test C++ microservices
        cd ${{ env.BUILD_DIR }}
        if [ -f "tests/users_service_tests" ]; then
          ./tests/users_service_tests
        fi
        if [ -f "tests/orders_service_tests" ]; then
          ./tests/orders_service_tests
        fi

        # Test API Gateway
        cd ..
        BUILD_PATH=${{ env.BUILD_DIR }} npm test

    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: deployment-package-${{ github.run_number }}
        path: |
          ${{ env.BUILD_DIR }}/services/
          api-gateway.js
          package*.json
          scripts/
          API-GATEWAY.md
          DEPLOY-*.md

  # Job 2: Deploy to production
  deploy:
    name: Deploy to Production
    runs-on: [self-hosted, Linux, X64, webserver, fedora]
    needs: build
    environment:
      name: ${{ github.event.inputs.environment || 'production' }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: deployment-package-${{ github.run_number }}
        path: ./deployment

    - name: Prepare production directory
      run: |
        echo "Preparing production directory: ${{ env.PRODUCTION_DIR }}"

        # Create production directory if it doesn't exist
        sudo mkdir -p ${{ env.PRODUCTION_DIR }}
        sudo chown $USER:$USER ${{ env.PRODUCTION_DIR }}

        # Backup existing deployment if it exists
        if [ -d "${{ env.PRODUCTION_DIR }}/api-gateway.js" ]; then
          echo "Backing up existing deployment..."
          sudo cp -r ${{ env.PRODUCTION_DIR }} ${{ env.PRODUCTION_DIR }}.backup.$(date +%Y%m%d_%H%M%S)
        fi

    - name: Stop existing services
      run: |
        echo "Stopping existing services..."

        # Stop PM2 processes if running
        if command -v pm2 &> /dev/null; then
          pm2 stop api-gateway || echo "PM2 api-gateway not running"
          pm2 delete api-gateway || echo "PM2 api-gateway not found"
        fi

        # Stop Docker containers if running
        if command -v docker &> /dev/null; then
          docker stop api-gateway || echo "Docker api-gateway not running"
          docker rm api-gateway || echo "Docker api-gateway not found"
        fi

        # Stop systemd service if running
        sudo systemctl stop api-gateway || echo "Systemd api-gateway not running"

    - name: Deploy files
      run: |
        echo "Deploying files to production..."

        # Copy all files to production directory
        cp -r . ${{ env.PRODUCTION_DIR }}/

        # Copy build artifacts
        cp -r deployment/services ${{ env.PRODUCTION_DIR }}/build/ || true

        # Set correct permissions
        cd ${{ env.PRODUCTION_DIR }}
        chmod +x scripts/*.sh
        chmod +x build/services/*/users_service || true
        chmod +x build/services/*/orders_service || true

    - name: Install production dependencies
      run: |
        cd ${{ env.PRODUCTION_DIR }}

        # Install Node.js dependencies
        npm ci --production

        # Install PM2 globally if not already installed
        if ! command -v pm2 &> /dev/null; then
          sudo npm install -g pm2
        fi

    - name: Configure firewall
      run: |
        echo "Configuring firewall..."
        sudo firewall-cmd --permanent --add-port=8080/tcp || echo "Port 8080 already open"
        sudo firewall-cmd --reload || echo "Firewall reload failed"

    - name: Start API Gateway
      run: |
        cd ${{ env.PRODUCTION_DIR }}

        echo "Starting API Gateway with PM2..."

        # Create a simple PM2 config
        echo 'module.exports = {
          apps: [{
            name: "api-gateway",
            script: "api-gateway.ts",
            interpreter: "node",
            interpreter_args: "--require ts-node/register",
            instances: "max",
            exec_mode: "cluster",
            env: {
              NODE_ENV: "production",
              PORT: 8080,
              BUILD_PATH: "/opt/rdws_webserver/build",
              SERVICE_TIMEOUT: 5000
            },
            error_file: "/var/log/api-gateway/error.log",
            out_file: "/var/log/api-gateway/out.log",
            log_file: "/var/log/api-gateway/combined.log",
            time: true,
            max_memory_restart: "500M"
          }]
        };' > ecosystem.config.js

        # Create log directory
        sudo mkdir -p /var/log/api-gateway
        sudo chown $USER:$USER /var/log/api-gateway

        # Start with PM2
        pm2 start ecosystem.config.js
        pm2 save

        # Setup PM2 startup if not already done
        pm2 startup --service-name rdws-api-gateway | grep "sudo" | bash || echo "PM2 startup already configured"

    - name: Health check
      run: |
        echo "Performing health check..."

        # Wait for service to start
        sleep 10

        # Use our verification script
        cd ${{ env.PRODUCTION_DIR }}
        chmod +x scripts/verify-deploy.sh
        ./scripts/verify-deploy.sh localhost 8080

    - name: Deploy summary
      run: |
        echo "Deployment completed successfully!"
        echo ""
        echo "Deployment Summary:"
        echo "  Environment: ${{ github.event.inputs.environment || 'production' }}"
        echo "  Directory: ${{ env.PRODUCTION_DIR }}"
        echo "  API Gateway: http://$(hostname -I | awk '{print $1}'):8080"
        echo "  Health Check: http://$(hostname -I | awk '{print $1}'):8080/health"
        echo ""
        echo "Management Commands:"
        echo "  Status: pm2 status"
        echo "  Logs: pm2 logs api-gateway"
        echo "  Restart: pm2 restart api-gateway"
        echo "  Monitor: pm2 monit"
        echo ""
        echo "Endpoints:"
        echo "  GET /health - Service health"
        echo "  GET /users - List users"
        echo "  GET /orders - List orders"
        echo "  GET /api-docs - API documentation"

  # Job 3: Post-deployment tests
  post-deploy-tests:
    name: Post-Deployment Tests
    runs-on: [self-hosted, Linux, X64, webserver, fedora]
    needs: deploy

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Run comprehensive tests
      run: |
        echo "Running post-deployment tests..."

        # Wait a bit more for service to stabilize
        sleep 15

        # Run verification script
        chmod +x scripts/verify-deploy.sh
        ./scripts/verify-deploy.sh localhost 8080

    - name: Performance baseline test
      run: |
        echo "Running performance baseline test..."

        BASE_URL="http://localhost:8080"

        # Test response times
        echo "Testing endpoint response times:"

        for endpoint in "/health" "/users" "/orders"; do
          echo -n "$endpoint: "
          time_total=$(curl -s -w "%{time_total}" -o /dev/null "$BASE_URL$endpoint")
          time_ms=$(echo "$time_total * 1000 / 1" | bc)
          echo "${time_ms}ms"
        done

    - name: Load test (basic)
      run: |
        echo "Running basic load test..."

        # Simple concurrent requests test
        BASE_URL="http://localhost:8080"

        echo "Testing 10 concurrent requests to /health..."
        seq 1 10 | xargs -n1 -P10 -I{} curl -s "$BASE_URL/health" > /dev/null

        if [ $? -eq 0 ]; then
          echo "Load test passed"
        else
          echo "Load test failed"
          exit 1
        fi
