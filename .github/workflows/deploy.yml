name: Deploy to Server

on:
  push:
    branches: [ main ]
  workflow_dispatch:  # Allow manual trigger
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging

env:
  PKG_CONFIG_PATH: /usr/local/lib64/pkgconfig:/usr/local/lib/pkgconfig
  BUILD_DIR: ${{ github.workspace }}/build
  PRODUCTION_DIR: /home/rdias/cpp-rest-server

jobs:
  deploy:
    name: Deploy to Fedora Server
    runs-on: [self-hosted, Linux, X64, webserver, fedora]
    environment:
      name: ${{ github.event.inputs.environment || 'production' }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Clean and prepare
      run: |
        # Clean previous builds
        rm -rf build
        mkdir -p build

        # Create .deployignore if it doesn't exist
        if [ ! -f .deployignore ]; then
          cat > .deployignore << 'EOF'
        # Build artifacts
        build/
        *.o
        *.a
        *.so
        *.dylib
        *.exe

        # IDE files
        .vscode/settings.json
        .vscode/launch.json
        .idea/
        *.swp
        *.swo

        # OS files
        .DS_Store
        Thumbs.db
        desktop.ini

        # Logs and temporary files
        *.log
        *.tmp
        *.temp
        *~
        .#*

        # Test results
        test_results.xml
        *.gcov
        *.gcda
        *.gcno

        # Git
        .git/

        # GitHub Actions
        .github/
        EOF
        fi

    - name: Set permissions
      run: |
        chmod +x scripts/*.sh

    - name: Build project
      run: |
        cd build
        PKG_CONFIG_PATH=${{ env.PKG_CONFIG_PATH }} cmake .. \
          -DCMAKE_BUILD_TYPE=Release \
          -DCMAKE_CXX_STANDARD=17
        make -j$(nproc)

        # Build individual services
        echo "Building C++ services..."
        cd services
        make -j$(nproc) || echo "Services build completed"

    - name: Run tests
      run: |
        cd ${{ env.BUILD_DIR }}
        make unit_tests integration_tests
        ./tests/unit_tests --gtest_output=xml:unit_test_results.xml
        ./tests/integration_tests --gtest_output=xml:integration_test_results.xml

    - name: Upload test reports
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: server-test-results-${{ github.run_number }}
        path: ${{ env.BUILD_DIR }}/*test_results.xml

    - name: Stop existing server
      run: |
        # Stop systemd service if running
        sudo systemctl stop cpp-rest-server || echo "Service not running"

    - name: Deploy to production directory
      run: |
        # Create production directory if it doesn't exist
        mkdir -p ${{ env.PRODUCTION_DIR }}

        # Copy executable and essential files to production
        cp ${{ env.BUILD_DIR }}/rest_server ${{ env.PRODUCTION_DIR }}/
        cp -r scripts ${{ env.PRODUCTION_DIR }}/
        cp cpp-rest-server.service ${{ env.PRODUCTION_DIR }}/

        # Copy C++ service executables
        mkdir -p ${{ env.PRODUCTION_DIR }}/services
        if [ -f ${{ env.BUILD_DIR }}/services/users/users_service ]; then
          cp ${{ env.BUILD_DIR }}/services/users/users_service ${{ env.PRODUCTION_DIR }}/services/
          echo "users_service copied"
        fi
        if [ -f ${{ env.BUILD_DIR }}/services/orders/orders_service ]; then
          cp ${{ env.BUILD_DIR }}/services/orders/orders_service ${{ env.PRODUCTION_DIR }}/services/
          echo "orders_service copied"
        fi

        # Copy environment configuration
        cp .env.example ${{ env.PRODUCTION_DIR }}/
        if [ ! -f ${{ env.PRODUCTION_DIR }}/.env ]; then
          # Create production .env if it doesn't exist
          cat > ${{ env.PRODUCTION_DIR }}/.env << 'EOF'
        # Production Configuration
        SERVERLESS_FUNCTION_URL=http://localhost:8082/
        ENVIRONMENT=production
        EOF
          echo "Created production .env file"
        else
          echo "Production .env file already exists, keeping current configuration"
        fi

        # Make executable
        chmod +x ${{ env.PRODUCTION_DIR }}/rest_server
        chmod +x ${{ env.PRODUCTION_DIR }}/scripts/*.sh

    - name: Deploy serverless functions
      run: |
        # Stop and remove existing function containers
        docker stop hello-function users-function orders-function || echo "Containers not running"
        docker rm hello-function users-function orders-function || echo "Containers not found"

        # Create serverless function directory
        mkdir -p ${{ env.PRODUCTION_DIR }}/functions

        # Copy function files
        if [ -d "functions" ]; then
          cp -r functions/* ${{ env.PRODUCTION_DIR }}/functions/
        fi

        # Build and deploy functions (if they exist)
        if [ -f "functions/stack.yaml" ]; then
          cd functions

          # Build hello function
          if [ -f "hello-simple/handler.js" ]; then
            echo "Building hello-simple function..."
            faas-cli build -f stack.yaml --filter hello-simple
            docker run -d --name hello-function --restart=always -p 8082:8080 local/hello-simple:latest
            echo "hello-simple function deployed on port 8082"
          fi

          # Build users function
          if [ -f "users-api/handler.js" ]; then
            echo "Building users-api function..."
            faas-cli build -f stack.yaml --filter users-api
            docker run -d --name users-function --restart=always -p 8083:8080 local/users-api:latest
            echo "users-api function deployed on port 8083 (calls C++ users_service)"
          fi

          # Build orders function
          if [ -f "orders-api/handler.js" ]; then
            echo "Building orders-api function..."
            faas-cli build -f stack.yaml --filter orders-api
            docker run -d --name orders-function --restart=always -p 8084:8080 local/orders-api:latest
            echo "orders-api function deployed on port 8084 (calls C++ orders_service)"
          fi
        else
          echo "No serverless functions found to deploy"
        fi

    - name: Install/Update systemd service
      run: |
        # Copy service file to systemd directory
        sudo cp ${{ env.PRODUCTION_DIR }}/cpp-rest-server.service /etc/systemd/system/

        # Reload systemd and enable service
        sudo systemctl daemon-reload
        sudo systemctl enable cpp-rest-server

    - name: Start server
      run: |
        # Start via systemd
        sudo systemctl start cpp-rest-server

    - name: Wait for server startup
      run: |
        sleep 5

    - name: Verify deployment
      run: |
        # Check service status
        if sudo systemctl is-active --quiet cpp-rest-server; then
          echo "Service is running"
          sudo systemctl status cpp-rest-server --no-pager
        else
          echo "Service failed to start"
          sudo systemctl status cpp-rest-server --no-pager
          sudo journalctl -u cpp-rest-server --no-pager -n 20
          exit 1
        fi

    - name: Health check
      run: |
        # Try to reach the server endpoint
        MAX_RETRIES=5
        RETRY_COUNT=0

        echo "Testing main C++ server..."
        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
          if curl -f http://localhost:9080/hello --max-time 10; then
            echo "Main server is responding"
            break
          else
            echo "Attempt $((RETRY_COUNT + 1))/$MAX_RETRIES failed, retrying..."
            RETRY_COUNT=$((RETRY_COUNT + 1))
            sleep 5
          fi
        done

        if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
          echo "Main server health check failed after $MAX_RETRIES attempts"
          exit 1
        fi

        # Test serverless function if it exists
        RETRY_COUNT=0
        echo "Testing serverless function..."
        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
          if curl -f http://localhost:8082/ --max-time 10; then
            echo "Serverless function is responding"
            break
          else
            echo "Serverless function attempt $((RETRY_COUNT + 1))/$MAX_RETRIES failed, retrying..."
            RETRY_COUNT=$((RETRY_COUNT + 1))
            sleep 5
          fi
        done

        if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
          echo "Serverless function health check failed, but continuing deployment"
        fi

        echo "Health checks completed"

  notify:
    name: Notify deployment status
    runs-on: self-hosted
    needs: deploy
    if: always()

    steps:
    - name: Deployment Success
      if: needs.deploy.result == 'success'
      run: |
        echo "Deployment to ${{ github.event.inputs.environment || 'production' }} successful!"
        echo "Server is available at http://localhost:9080"
        echo "Health check: curl http://localhost:9080/hello"

    - name: Deployment Failed
      if: needs.deploy.result == 'failure'
      run: |
        echo "Deployment to ${{ github.event.inputs.environment || 'production' }} failed!"
        echo "Check the logs above for details"
        exit 1
